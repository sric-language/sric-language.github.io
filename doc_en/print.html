<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sric doc</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sric doc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sric-language"><a class="header" href="#sric-language">Sric Language</a></h1>
<p>A memory-safe low-level systems programming language. It is based on ownership semantics, provides runtime memory safety checks, and generates human-readable C++ code.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Blazing fast: low-level memeory access without GC.</li>
<li>Optional Memory safe: nearly leak-free, No dangling pointers or other common C++ memory issues.</li>
<li>Easy to learn: No borrow checking, lifetime annotations. No various constructors/assignment, template metaprogramming, function overloading.</li>
<li>Interoperate with C++: compile to human readable C++ code. Leverage existing code and tools.</li>
<li>Modern features: object-oriented, null safe, dynamic reflection，template, closure, coroutine.</li>
<li>Tools: VSCode plugin and LSP support.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-sric"><a class="header" href="#why-sric">Why Sric</a></h2>
<p>The design of Sric draws heavily from C++, but it makes two key improvements:</p>
<ol>
<li>Reducing features and complexity.</li>
<li>Adding memory safety.</li>
</ol>
<h3 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h3>
<h4 id="performance"><a class="header" href="#performance">Performance</a></h4>
<p>The notion that "modern computers are fast enough" is a childhood myth. Hardware advancements can’t keep up with the growing complexity of problems. Every industry I’ve encountered faces performance issues. To solve performance problems, the first step is to eliminate garbage collection (GC). Languages with GC inherently have an invisible performance ceiling. A high-performance language must provide low-level memory manipulation and flexible stack allocation. From the outset, Sric has been designed to match the performance of C/C++.</p>
<h4 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h4>
<p>Memory safety and performance can coexist. However, Rust's mechanisms impose restrictions on code functionality, forcing developers to write complex and inefficient code while increasing the learning curve.<br />
In contrast, Sric takes a different approach—developers don’t need to do anything extra to achieve memory safety. <a href="intro/memory.html">How Memory Safety Works</a></p>
<h4 id="abstraction-capabilities"><a class="header" href="#abstraction-capabilities">Abstraction Capabilities</a></h4>
<p>Object-oriented programming (OOP) is a key measure of a language’s abstraction power. Although misuse of inheritance has given OOP a bad reputation, I believe it remains useful in certain scenarios. Sric supports OOP but imposes language-level restrictions on inheritance.</p>
<h4 id="simplicity-and-ease"><a class="header" href="#simplicity-and-ease">Simplicity and Ease</a></h4>
<p>Both C++ and Rust have gone to the opposite extreme, attempting to cover every use case with complex features. Sric, on the other hand, strives to minimize features and avoid complexity. For example: No various versions of constructors/assignment functions, function overloading, or template metaprogramming (unlike C++). No borrow checking, macros, intricate module systems, or lifetime annotations (unlike Rust).</p>
<p>Sric avoids excessive syntactic sugar. While syntactic sugar can reduce verbosity, too much of it increases learning costs and may harm readability. The goal is to strike a balance between ease of use and cognitive overhead.</p>
<h4 id="interoperability-with-c"><a class="header" href="#interoperability-with-c">Interoperability with C++</a></h4>
<p>Sric seamlessly interoperates with C++ and can generate human-readable C++ code. C++ and C have long histories and vast ecosystems of high-quality libraries. Sric integrates smoothly into the C++ ecosystem, making it easy to leverage legacy code or call operating system APIs.</p>
<p>Additionally, Sric code can be easily invoked from C++, facilitating collaboration with developers who haven’t adopted Sric. For example, a team could use Sric internally while exposing C++ interfaces externally.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="data-type"><a class="header" href="#data-type">Data Type</a></h3>
<pre><code>var p: Int             //value type
var p: own* Int;       //ownership pointer
var p: * Int;          //non-owning pointer
var p: &amp; Int;          //reference
var p: raw* Int;       //unsafe raw pointer
var p: uniq* Int;      //unique pointer
</code></pre>
<h3 id="explicit-copy-or-move"><a class="header" href="#explicit-copy-or-move">Explicit Copy or Move</a></h3>
<p>Move or share ownership pointer</p>
<pre><code>var p: own* Int = ...;
var p1 = p; //compiler error;
var p2 = move p;
var p3 = share(p2);
</code></pre>
<p>Move or copy a struct with ownership pointer:</p>
<pre><code>struct A {
    var i: own* Int;
    fun copy(): A { ... }
}
var a: A;
var x = a; //compile error
var b = move a;
var c = a.copy();
</code></pre>
<h3 id="unsafe"><a class="header" href="#unsafe">Unsafe</a></h3>
<p>Dereference a raw pointer in an <code>unsafe</code> block/function:</p>
<pre><code>var p: raw* Int;
...
unsafe {
    var i = *p;
}
</code></pre>
<p>Unsafe functions must be called in an <code>unsafe</code> block/function:</p>
<pre><code>unsafe fun foo() { ... }

fun main() {
    unsafe {
        foo();
    }
}
</code></pre>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Single inheritance, similar to Java:</p>
<pre><code>trait I {
    virtual fun foo();
}

virtual struct B {
    var a: Int;
    fun bar() { ... }
}

struct A : B, I {
    override fun foo(B* b) {
        ...
    }
}

</code></pre>
<h3 id="with-block"><a class="header" href="#with-block">With-Block</a></h3>
<p>A with-block is not like C++'s named initialization; it can contain any statements:</p>
<pre><code>struct A {
    var i: Int;
    fun init() { ... }
}

var a  = A { .init(); .i = 0; };
var a: own* A = new A { .i = 0; };
</code></pre>
<h3 id="pointer-usage"><a class="header" href="#pointer-usage">Pointer Usage</a></h3>
<p>Always access by <code>.</code></p>
<pre><code>var a: A;
var b: own* A;
a.foo();
b.foo();
</code></pre>
<h3 id="type-cast-and-check"><a class="header" href="#type-cast-and-check">Type Cast and Check</a></h3>
<pre><code>var a = p as own* A;
var b = p is own* A;
</code></pre>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<p>Statically sized arrays:</p>
<pre><code>var a  = []Int { 1,2,3 };
var a: [15]Int;
</code></pre>
<h3 id="generic-type"><a class="header" href="#generic-type">Generic Type</a></h3>
<p>Generic params start with <code>$&lt;</code></p>
<pre><code>struct Bar$&lt;T&gt; {
    fun foo() {
        ...
    }
}

T fun foo$&lt;T&gt;(a: T) {
    return a;
}

var b: Bar$&lt;Int&gt;;
</code></pre>
<h3 id="null-safe"><a class="header" href="#null-safe">Null safe</a></h3>
<p>Pointer is non-nullable by default.</p>
<pre><code>var a: own*? B;
var b: own* B = a;
</code></pre>
<h3 id="immutable"><a class="header" href="#immutable">Immutable</a></h3>
<p>Similar to C++:</p>
<pre><code>var p : raw* const Int;
var p : const raw* Int;
var p : const raw* const Int;
</code></pre>
<h3 id="protection"><a class="header" href="#protection">Protection</a></h3>
<pre><code>public
private
protected
readonly
</code></pre>
<p><code>readonly</code> means publicly readable but privately writable.</p>
<h3 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h3>
<pre><code>struct A {
    operator fun mult(a: A): A { ... }
}

var c = a * b;
</code></pre>
<p>Overloadable operators:</p>
<pre><code>methods    symbol
------     ------
plus       a + b 
minus      a - b 
mult       a * b 
div        a / b 
get        a[b] 
set        a[b] = c
compare    == != &lt; &gt; &lt;= &gt;=
add        a,b,c;
</code></pre>
<h3 id="module"><a class="header" href="#module">Module</a></h3>
<p>Module is namespace as well as the unit of compilation and deployment.</p>
<p>A module contains several source files and folders.</p>
<p>The module is defined in build scripts:</p>
<pre><code>name = hello
summary = hello
outType = exe
version = 1.0
depends = sric 1.0, cstd 1.0
srcDirs = ./
</code></pre>
<p>import external module in code:</p>
<pre><code>import std::*;
import std::Vec;
</code></pre>
<h3 id="closure"><a class="header" href="#closure">Closure</a></h3>
<pre><code>fun foo(f: fun(a:Int) ) {
    f(1);
}

foo(fun(a:Int){ ... });
</code></pre>
<h3 id="type-alias"><a class="header" href="#type-alias">Type Alias</a></h3>
<p>typealias:</p>
<pre><code>typealias VecInt = std::Vec$&lt;Int&gt;;
</code></pre>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<pre><code>enum Color {
    red = 1, green, blue
}

var c = Color::red;
</code></pre>
<h3 id="default-params-and-named-args"><a class="header" href="#default-params-and-named-args">Default Params and Named Args</a></h3>
<pre><code>fun foo(a: Int, b: Int = 0) {
}

fun main() {
    foo(a : 10);
}
</code></pre>
<h3 id="coroutine"><a class="header" href="#coroutine">Coroutine</a></h3>
<pre><code>async fun test2() : Int {
    var i = 0;
    i = await testCallback();
    return i + 1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="from-c-to-sric"><a class="header" href="#from-c-to-sric">From C++ to Sric</a></h2>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Sric</th></tr></thead><tbody>
<tr><td>int</td><td>Int</td></tr>
<tr><td>short</td><td>Int16</td></tr>
<tr><td>int32_t</td><td>Int32</td></tr>
<tr><td>unsigned int</td><td>UInt32</td></tr>
<tr><td>int64_t</td><td>Int64</td></tr>
<tr><td>uint64_t</td><td>UInt64</td></tr>
<tr><td>float</td><td>Float32</td></tr>
<tr><td>double</td><td>Float/Float64</td></tr>
<tr><td>void</td><td>Void</td></tr>
<tr><td>char</td><td>Int8</td></tr>
</tbody></table>
</div>
<h3 id="defines"><a class="header" href="#defines">Defines</a></h3>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Sric</th></tr></thead><tbody>
<tr><td>const char* str</td><td>var str: raw* Int8</td></tr>
<tr><td>void foo(int i) {}</td><td>fun foo(i: Int) {}</td></tr>
<tr><td>char a[4]</td><td>var a: [4]Int8</td></tr>
<tr><td>const int&amp; a</td><td>var a: &amp; const Int</td></tr>
</tbody></table>
</div>
<h3 id="class"><a class="header" href="#class">Class</a></h3>
<p>C++</p>
<pre><code>#include &lt;math.h&gt;

class Point {
public:
    int x;
    int y;
    double dis(const Point &amp;t) const {
        int dx = t.x - x;
        int dy = t.y - y;
        return sqrt(dx*dx + dy*dy);
    }
};
</code></pre>
<p>Sric:</p>
<pre><code>import cstd::*;

struct Point {
    var x: Int;
    var y: Int;
    fun dis(t: &amp; const Point) const: Float {
        var dx = t.x - x;
        var dy = t.y - y;
        return sqrt(dx*dx + dy*dy);
    }
};
</code></pre>
<h2 id="features-compare"><a class="header" href="#features-compare">Features Compare</a></h2>
<h3 id="removed-features-from-c"><a class="header" href="#removed-features-from-c">Removed features from C++</a></h3>
<ul>
<li>No function overload by params</li>
<li>No header file</li>
<li>No implicit copying of large objects</li>
<li>No define multi var per statement</li>
<li>No nested class, nested function</li>
<li>No class, only struct</li>
<li>No namespace</li>
<li>No macro</li>
<li>No forward declarations</li>
<li>No three static</li>
<li>No friend class</li>
<li>No multiple inheritance</li>
<li>No virtual,private inheritance</li>
<li>No i++ only ++i</li>
<li>No switch auto fallthrough</li>
<li>No template specialization</li>
<li>No various constructors</li>
</ul>
<h3 id="more-than-c"><a class="header" href="#more-than-c">More than C++</a></h3>
<ul>
<li>Simple and easy</li>
<li>Memory safe</li>
<li>Modularization</li>
<li>With block</li>
<li>Non-nullable pointer</li>
<li>Dynamic reflection</li>
<li>Named args</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-memory-safety-works"><a class="header" href="#how-memory-safety-works">How Memory Safety Works</a></h1>
<p>Memory safety, performance, and simplicity form an impossible triangle - choosing any two necessitates sacrificing the third. Sric innovatively adopts runtime memory safety checks, eliminating overhead while significantly reducing memory vulnerabilities.</p>
<h2 id="why-not-rust"><a class="header" href="#why-not-rust">Why Not Rust</a></h2>
<p>Both Sric and Rust are memory-safe languages without garbage collection, but they differ fundamentally. Rust enforces safety at compile-time, whereas Sric implements runtime memory checks. Rust's safety mechanisms impose numerous coding restrictions, forcing developers to write complex code. Such complexity not only harms readability but often fails to achieve zero-cost abstraction. Sric's safety layer is transparent, requiring no extra effort to achieve memory safety.</p>
<h2 id="optional-memory-safety"><a class="header" href="#optional-memory-safety">Optional Memory Safety</a></h2>
<p>Although Sric's memory checks have minimal overhead, they are disabled by default in Release mode to achieve zero-cost abstractions and maximize performance. So the standard workflow is to debug the code in Debug mode, ensure there are no memory issues, and then compile it in Release for deployment.</p>
<p>In other words, Sric is not fully memory-safe, safety becomes optional based on project requirements. For projects prioritizing safety over performance, compilation macros can enable memory safety in Release mode.</p>
<h2 id="lifetime-verification"><a class="header" href="#lifetime-verification">Lifetime Verification</a></h2>
<p>Sric's safety checks cover: Array bounds checking, Null pointer checking, Wild pointer prevention, Dangling pointer checking. The ownership model inherently prevents memory leaks and double-free errors. The other checks are relatively straightforward, the core challenge of memory safety lies in detecting dangling pointers, which essentially involves verifying memory lifetimes.</p>
<p>In Sric, a non-ownership pointer is a "fat pointer," which includes the actual pointer and a verification code, among other details. The object's memory also contains an identical verification code. When a pointer is created, its verification code matches the object's. When memory is released, this code is set to 0. Each time the pointer is used, the verification codes of the pointer and the object are compared. If they differ, it indicates the object's memory has been freed. An error is reported immediately, preventing the issue from propagating, making it easy to locate the problem.</p>
<p>Although the principle is straightforward, several challenges must be addressed: handling derived pointers (pointers to the middle of memory rather than the start), managing memory arrays, distinguishing between heap and stack allocations, and dealing with non-cooperative objects (e.g., C++ classes with no space for verification codes). Fortunately, Sric has resolved most of these issues.</p>
<h2 id="vs-address-sanitizer"><a class="header" href="#vs-address-sanitizer">vs. Address Sanitizer</a></h2>
<p>AddressSanitizer (ASan) has several limitations:</p>
<ul>
<li>False negatives (e.g., can't detect reallocated memory use)</li>
<li>High overhead (memory and performance)</li>
<li>Platform dependence (primarily Clang/GCC, some ARM-specific)</li>
<li>Requires recompiling dependencies</li>
</ul>
<p>Sric works in language level not system level. Sric provides more comprehensive checks with lower overhead, and works on any platform that supports C++.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<h3 id="1required"><a class="header" href="#1required">1.Required</a></h3>
<ul>
<li><a href="https://www.oracle.com/java/technologies/downloads/">JDK 17+</a></li>
<li>C++ compiler (supporting C++20): gcc 11+, clang 17+, Xcode 16+, Visual Studio 2022+</li>
<li><a href="https://github.com/fanx-dev/fanx/releases">Fanx</a></li>
<li><a href="https://cmake.org/download/">CMake</a></li>
<li><a href="https://git-scm.com/downloads">git</a></li>
<li><a href="https://code.visualstudio.com/">VSCode</a></li>
</ul>
<p>Install the above software and configure the environment variables to ensure that commands such as java, jar, fan, and cmake are available in git bash.</p>
<h3 id="2build-fmake"><a class="header" href="#2build-fmake">2.Build fmake</a></h3>
<pre><code>git clone https://github.com/chunquedong/fmake.git
cd fmake
fanb pod.props
</code></pre>
<p>Use the Microsoft C++ compiler toolchain on Windows:</p>
<pre><code>cd fmake
source vsvars.sh
cd -
</code></pre>
<p><a href="https://github.com/chunquedong/fmake">About fmake</a></p>
<h3 id="3build-jsonc"><a class="header" href="#3build-jsonc">3.Build jsonc</a></h3>
<pre><code>git clone https://github.com/chunquedong/jsonc.git
cd jsonc
sh build.sh
</code></pre>
<h3 id="6build-sric"><a class="header" href="#6build-sric">6.Build Sric</a></h3>
<pre><code>git clone https://github.com/sric-language/sric.git
cd sric
chmod a+x bin/sric
sh build.sh
sh build_debug.sh
</code></pre>
<p>Add sric/bin to your PATH (restart git bash afterward).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-1"><a class="header" href="#install-1">Install</a></h1>
<p><a href="start/build.html">build from source</a></p>
<h1 id="ide"><a class="header" href="#ide">IDE</a></h1>
<ol>
<li>Search 'sric-language' in vscode marketplace, install it.</li>
<li>Configure sricHome to point to the sric directory (the parent directory of bin).</li>
</ol>
<p>After configuring, restart VSCode. If features such as Go to Definition, Auto Completion, and Outline View are available, it means the configuration was successful. If you recompile the Sric source code, you need to close VSCode first.</p>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<ol>
<li>
<p>Create an empty folder as the workspace</p>
</li>
<li>
<p>Create a file named main.sric with the following content:</p>
</li>
</ol>
<pre><code>import cstd::*;

fun main(): Int {
    printf("Hello World\n");
    return 0;
}
</code></pre>
<ol start="3">
<li>Create a module.scm file with the following content:</li>
</ol>
<pre><code>name = hello  
summary = hello  
outType = exe  
version = 1.0  
depends = sric 1.0, cstd 1.0  
srcDirs = ./
</code></pre>
<ol start="4">
<li>Build</li>
</ol>
<pre><code>sric module.scm -fmake
</code></pre>
<p>build debug mode:</p>
<pre><code>sric module.scm -fmake -debug
</code></pre>
<ol start="5">
<li>Run</li>
</ol>
<p>After compilation, the console will print the output file path. Run it with quotes. For example:</p>
<pre><code>'C:\Users\xxx\fmakeRepo\msvc\test-1.0-debug\bin\test'
</code></pre>
<h2 id="build-by-fmake"><a class="header" href="#build-by-fmake">Build by fmake</a></h2>
<p>The build process without -fmake solely outputs C++ code (under "sric/output").</p>
<pre><code>sric hello.scm
</code></pre>
<p>Then compile it separately by manually running fmake:</p>
<pre><code>fan fmake output/hello.fmake -debug
</code></pre>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>Debugging the generated C++ code is supported via IDE project generation.</p>
<pre><code>fan fmake output/hello.fmake -debug -G
</code></pre>
<p>The generated project files are located in the build folder under the parent directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="guess-number-game"><a class="header" href="#guess-number-game">Guess Number Game</a></h2>
<pre><code>import cstd::*;
import sric::*;

fun main(): Int {
    //init random seed
    srand(currentTimeMillis());

    //random 0..50
    var expected = (rand() / (RAND_MAX as Float32)  * 50) as Int;
    var guess = 0;

    printf("Please input your guess\n");
    while (true) {
        //get input
        var guess = 0;
        scanf("%d", (&amp;guess as raw*Int));

        if (guess &gt; expected) {
            printf("Too big\n");
        }
        else if (guess &lt; expected) {
            printf("Too small\n");
        }
        else {
            printf("You win!\n");
            break;
        }
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h3>
<ul>
<li>Int, Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64</li>
<li>Float, Float32, Float64</li>
<li>Bool</li>
<li>Void</li>
</ul>
<p>Int is 32-bit by default, Float is 64-bit by default.</p>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings can span multiple lines:</p>
<pre><code>var s = "ab
            cd";
</code></pre>
<p>Triple-quoted strings don't require escaping double quotes:</p>
<pre><code>var s = """ab"
            cd""";
</code></pre>
<p>String literals are of type raw*const Int8 and can be automatically converted to sric::String.</p>
<h3 id="characters"><a class="header" href="#characters">Characters</a></h3>
<p>A character represents a single letter and is of type Int8:</p>
<pre><code>var c : Int8 = 'A';
</code></pre>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Single-line comment:</p>
<pre><code>//comment
</code></pre>
<p>Multi-line comment:</p>
<pre><code>/*
comment
*/
</code></pre>
<p>Documentation comment:</p>
<pre><code>/**
introduction
*/
</code></pre>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<pre><code>//@method: GET
</code></pre>
<p>Annotations can be dynamically accessed through reflection interfaces.</p>
<h3 id="variable-declaration"><a class="header" href="#variable-declaration">Variable Declaration</a></h3>
<ul>
<li>Use <code>var</code> to declare variables, regardless of mutability.</li>
<li>Type annotations come after the variable name.</li>
<li>Only one variable can be declared per statement.</li>
</ul>
<pre><code>var i: Int = 0;
</code></pre>
<p>Type inference is only supported for local variables within functions:</p>
<pre><code>var i = 0;
</code></pre>
<p>Variables are automatically initialized to default values. Use <code>uninit</code> keyword to keep random values:</p>
<pre><code>var i = uninit;
</code></pre>
<p>Global variables must be immutable unless marked with <code>unsafe</code>:</p>
<pre><code>var i: const Int = 0;
</code></pre>
<h3 id="function-definition"><a class="header" href="#function-definition">Function Definition</a></h3>
<ul>
<li>Functions start with <code>fun</code></li>
<li>Return type can be omitted when it's Void</li>
<li>Function names must be unique (no parameter-based overloading)</li>
</ul>
<pre><code>fun foo(a: Int): Int { return 0; }
fun foo2() {}
</code></pre>
<p>Default parameters and named parameters:</p>
<pre><code>fun foo(a: Int, b: Int = 0) {}
foo(a: 1);
</code></pre>
<p>Named parameters improve readability by explicitly showing parameter names.</p>
<h3 id="forward-declaration"><a class="header" href="#forward-declaration">Forward Declaration</a></h3>
<p>There's no forward declaration like in C/C++. Functions can call others defined later in the code because Sric uses a multi-pass compiler architecture.</p>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<p>Variables and functions support visibility markers:</p>
<pre><code>public
private
protected
readonly
</code></pre>
<p>Examples:</p>
<pre><code>private fun foo() {}
readonly var i: Int = 0;
</code></pre>
<ul>
<li>Visibility scope for global variables and functions is the current file. <code>private</code> makes them invisible to other files.</li>
<li>Default visibility is <code>public</code> (no need to explicitly specify).</li>
<li><code>protected</code> means visible within the current module or to derived classes.</li>
<li><code>readonly</code> can only modify variables (not functions), meaning public read but private write access.</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="value-types"><a class="header" href="#value-types">Value Types</a></h2>
<p>By default, variables in Sric are value types that get automatically copied during assignment/passing. Pointer types only copy the pointer itself, not the pointed-to object.</p>
<h2 id="pointers"><a class="header" href="#pointers">Pointers</a></h2>
<ul>
<li>Three pointer types: owning, non-owning, and raw</li>
<li>Asterisk placement differs from C/C++ (before type)</li>
</ul>
<pre><code class="language-sric">var p: Int             // Value type
var p: own* Int;       // Owning pointer
var p: * Int;          // Non-owning pointer
var p: &amp; Int;          // Reference
var p: raw* Int;       // Raw pointer
var p: uniq* Int;      // Unique pointer
</code></pre>
<p>Sric also provides C++-style smart pointers (SharedPtr, WeakPtr) via standard library.</p>
<h3 id="memory-allocation"><a class="header" href="#memory-allocation">Memory Allocation</a></h3>
<p>Get pointers via address-of operator or <code>new</code>:</p>
<pre><code class="language-sric">var i: own* Int = new Int;  // Parentheses omitted (no constructors)
</code></pre>
<h4 id="owning-pointers"><a class="header" href="#owning-pointers">Owning Pointers</a></h4>
<ul>
<li>Own their objects (auto-released at scope exit)</li>
<li>Require explicit move/copy during transfer:</li>
</ul>
<pre><code class="language-sric">var p1: own* Int = ...;
var p2 = move p1;          // Transfer ownership
var p3 = share(p1);        // Shared ownership
</code></pre>
<h4 id="unique-pointers"><a class="header" href="#unique-pointers">Unique Pointers</a></h4>
<p><code>uniq*</code> is zero-overhead. Similar to <code>own*</code>, but without a share() method.</p>
<pre><code class="language-sric">var p1: uniq* Int = makeUniq$&lt;T&gt;();
var p2 = move p1;
</code></pre>
<h4 id="non-owning-pointers"><a class="header" href="#non-owning-pointers">Non-owning Pointers</a></h4>
<ul>
<li>No borrowing restrictions like Rust</li>
<li>Runtime validity checks</li>
<li>Implicit conversion from <code>own*</code>/<code>uniq*</code>:</li>
</ul>
<pre><code class="language-sric">var p1: own* Int = ...;
var p4: * Int = p1;       // Non-owning
var p5: raw* Int = p1;    // Raw
</code></pre>
<h4 id="raw-pointers"><a class="header" href="#raw-pointers">Raw Pointers</a></h4>
<ul>
<li>C/C++-style pointers (require <code>unsafe</code>):</li>
</ul>
<pre><code class="language-sric">var p: raw* Int = ...;
unsafe {
    var i = *p;
}
</code></pre>
<h2 id="address-of-operator"><a class="header" href="#address-of-operator">Address-of Operator</a></h2>
<p>Get pointers from values (non-owning by default):</p>
<pre><code class="language-sric">var i: Int = 0;
var p: *Int = &amp;i;
</code></pre>
<h2 id="pointer-arithmetic"><a class="header" href="#pointer-arithmetic">Pointer Arithmetic</a></h2>
<p>Only allowed for raw pointers in <code>unsafe</code> contexts:</p>
<pre><code class="language-sric">var p : raw* Int = ...;
unsafe {
    ++p;
    p = p + 2;
}
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Similar to C++ but restricted to function parameters/returns:</p>
<pre><code class="language-sric">fun foo(a: &amp; const Int) {}  // Auto-dereferencing
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Fixed-size arrays (for dynamic arrays see <code>DArray</code>):</p>
<pre><code class="language-sric">var a: [5]Int;                // Explicit size
var a = []Int { 1,3,4 };      // Size inference
constexpr var size = 15;
var a: [size]Int;             // Constexpr size
</code></pre>
<h2 id="null-safety"><a class="header" href="#null-safety">Null Safety</a></h2>
<p>Pointers are non-nullable by default (use <code>?</code> for nullable):</p>
<pre><code class="language-sric">var a: own*? B = null;     // Valid
var a: own* B = null;      // Compile error
</code></pre>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p><code>const</code> can modify either pointer or pointee:</p>
<pre><code class="language-sric">var p : raw* const Int;     // Immutable value
var p : const raw* Int;     // Immutable pointer
var p : const raw* const Int;  // Both
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="statements"><a class="header" href="#statements">Statements</a></h2>
<ul>
<li>All statements end with semicolons</li>
<li>No <code>do while</code> or <code>goto</code> (otherwise same as C++)</li>
<li><code>switch</code> doesn't fall through by default (use <code>fallthrough</code> explicitly)</li>
</ul>
<pre><code class="language-sric">switch (i) {
    case 1:
        fallthrough;
    case 2:
        printf("%d\n", i);
}
</code></pre>
<h3 id="unsafe-1"><a class="header" href="#unsafe-1">Unsafe</a></h3>
<p>Dereference raw pointers in unsafe blocks:</p>
<pre><code class="language-sric">var p: *Int;
...
unsafe {
    var i = *p;
}
</code></pre>
<p>Unsafe functions require unsafe blocks:</p>
<pre><code class="language-sric">unsafe fun foo() { ... }

fun main() {
    unsafe {
        foo();
    }
}
</code></pre>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>Operator precedence matches C/C++ except bitwise operators have higher precedence than comparisons</p>
<pre><code class="language-sric">if (i &amp; Mask != 0) {}
// Equivalent to:
if ((i &amp; Mask) != 0) {}
</code></pre>
<p>Only prefix ++i is supported (no postfix i++)</p>
<h3 id="with-blocks"><a class="header" href="#with-blocks">With Blocks</a></h3>
<p>With blocks (unlike C++ designated initializers) can contain any statements:</p>
<pre><code class="language-sric">struct A {
    var i: Int;
    fun init() { ... }
}

var a = A { .init(); .i = 0; };
var a: own* A = new A { .i = 0; };
</code></pre>
<h2 id="pointer-access"><a class="header" href="#pointer-access">Pointer Access</a></h2>
<p>Use . for both direct and pointer access (no -&gt;):</p>
<pre><code class="language-sric">var a: A;
var b: own* A;
a.foo();
b.foo();
</code></pre>
<h2 id="type-conversionchecking"><a class="header" href="#type-conversionchecking">Type Conversion/Checking</a></h2>
<p>as for dynamic/numeric conversion, is for type checking:</p>
<pre><code class="language-sric">var a = p as own* A;
var b = p is own* A;
</code></pre>
<p>Other conversions use unsafeCast.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Since Sric does not support exception handling, Optional can serve as an alternative for error return.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>Classes don't have parameterized constructors - callers must initialize them manually:</p>
<pre><code>struct Point {
    var x: Int = 0;
    var y: Int = uninit;
    var z: Int;
}
var p = Point { .y = 1; };
</code></pre>
<p>Initialization uses with blocks (different from C's named initialization). These blocks can contain any statements and work in non-initialization contexts:</p>
<pre><code>var point = Point { .y = 1; };
point {
    .x = 2; if (a) { .y = 3; }
}
</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<ul>
<li>Types can have methods (non-static member functions with implicit this pointer)</li>
<li>Methods must appear after data members</li>
<li>Mutability modifier goes after function name:</li>
</ul>
<pre><code>struct Point {
    fun length() const : Float {
        ...
    }
}
</code></pre>
<h2 id="static-members"><a class="header" href="#static-members">Static Members</a></h2>
<p>Structs can contain static functions/fields (no implicit this):</p>
<pre><code>struct Point {
    static fun foo() {
    }
}
Point::foo();
</code></pre>
<h2 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h2>
<ul>
<li>No multiple inheritance (Java-like)</li>
<li>Base classes must be marked <code>virtual</code> or <code>abstract</code></li>
<li>Traits (like Java interfaces) can't have data members or method implementations</li>
<li>Inheritance list: class first (if any), then traits</li>
<li>Overriding requires <code>override</code> marker</li>
<li>Use <code>super</code> to call parent methods</li>
</ul>
<pre><code>virtual struct B {
    virtual fun foo() {}
}
trait I {
    abstract fun foo2();
}
struct A : B , I {
    override fun foo2() {}
}
</code></pre>
<h2 id="constructorsdestructors"><a class="header" href="#constructorsdestructors">Constructors/Destructors</a></h2>
<p>Sric has no C++-style constructors - only parameterless default initialization:</p>
<pre><code>struct A {
    fun new() {
    }
    fun delete() {
    }
}
</code></pre>
<p>Destructors are rarely needed due to automatic memory management via ownership. Constructors exist mainly to handle complex initialization logic:</p>
<pre><code>struct A {
    var p : own* Int = ...;
    fun new() {
        p = new Int;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>Type aliases are equivalent to C's typedef:</p>
<pre><code class="language-sric">typealias size_t = Int32;
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enums are similar to C++ but always scoped:</p>
<pre><code class="language-sric">enum Color {
    Red, Green = 2, Blue
}

fun foo(c: Color) {}

foo(Color::Red);
</code></pre>
<p>Explicit size specification:</p>
<pre><code class="language-sric">enum Color : UInt8 {
    Red, Green = 2, Blue
}
</code></pre>
<h2 id="unsafe-structures"><a class="header" href="#unsafe-structures">Unsafe Structures</a></h2>
<p>Unsafe structs match their C++ counterparts exactly, without safety check markers. Extern structs are unsafe by default.</p>
<p>Within unsafe structs, this is a raw pointer (not safe pointer). Objects allocated with new can be converted to safe pointers using rawToRef:</p>
<pre><code class="language-sric">unsafe struct A {
    fun foo() {
        var self = rawToRef(this);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<h3 id="generic-definition"><a class="header" href="#generic-definition">Generic Definition</a></h3>
<p>Unlike C++, generics use <code>$&lt;</code> prefix to disambiguate between type parameters and the less-than operator.</p>
<pre><code class="language-sric">struct Tree$&lt;T&gt; {
}
</code></pre>
<p>Type parameters can have example types for compile-time type checking:</p>
<pre><code>abstract struct Linkable$&lt;T&gt; {
    var next: own*? T;
    var previous: *? T;
}

struct LinkedList$&lt;T: Linkable$&lt;T&gt;&gt; {
}
</code></pre>
<h3 id="template-instantiation"><a class="header" href="#template-instantiation">Template Instantiation</a></h3>
<p>When instantiating generic templates, any type satisfying the example type constraints can be used:</p>
<pre><code>var tree = Tree$&lt;Int&gt; {};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="closureslambdas"><a class="header" href="#closureslambdas">Closures/Lambdas</a></h2>
<p>Anonymous functions are defined using the <code>fun</code> keyword:</p>
<pre><code>fun foo(f: fun(a:Int):Int) {
    f(1);
}

foo(fun(a:Int):Int{
    printf("%d\n", a);
    return a + 1;
});
</code></pre>
<p>Return type inference is not yet supported for closures - the return type must be explicitly specified.</p>
<h2 id="variable-capture"><a class="header" href="#variable-capture">Variable Capture</a></h2>
<p>By default, external variables are captured by value:</p>
<pre><code>var i = 0;
var f = fun(a:Int):Int{
    return a + i;
};
</code></pre>
<h2 id="static-closures"><a class="header" href="#static-closures">Static Closures</a></h2>
<p>Static closures are state-less closures marked with <code>static</code>. They cannot capture variables:</p>
<pre><code>var f : fun(a:Int) static : Int;
</code></pre>
<h2 id="reference-capture"><a class="header" href="#reference-capture">Reference Capture</a></h2>
<p>C++-style reference capture is not supported. For reference capture, you need to explicitly take the address:</p>
<pre><code>var i = 0;
var ri = &amp;i;
var f = fun(a:Int):Int{
    return a + *ri;
};
</code></pre>
<h2 id="move-capture"><a class="header" href="#move-capture">Move Capture</a></h2>
<p>C++-style move capture is not supported. Use <code>AutoMove</code> to wrap objects and avoid explicit move instructions:</p>
<pre><code>var arr: DArray;
var autoMove = AutoMove { .set(arr); };

var f = fun() {
    var s = autoMove.get().size();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="operator-overloading-1"><a class="header" href="#operator-overloading-1">Operator Overloading</a></h3>
<p>Use the <code>operator</code> keyword to overload operators:</p>
<pre><code class="language-sric">struct A {
    operator fun mult(a: A): A { ... }
}

var c = a * b;
</code></pre>
<p>Overloadable operators:</p>
<pre><code>Methods    Symbols
------     ------
plus       a + b
minus      a - b
mult       a * b
div        a / b
get        a[b]
set        a[b] = c
compare    == != &lt; &gt; &lt;= &gt;=
add        a,b,c;
</code></pre>
<h3 id="comma-operator"><a class="header" href="#comma-operator">Comma Operator</a></h3>
<p>The comma operator only works within with blocks:</p>
<pre><code class="language-sric">x { a, b, c; };
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-sric">x { .add(a).add(b).add(c); }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modularization"><a class="header" href="#modularization">Modularization</a></h2>
<p>In Sric, modules serve as namespaces, compilation units, and deployment units. Software consists of multiple interdependent modules.</p>
<h3 id="module-definition"><a class="header" href="#module-definition">Module Definition</a></h3>
<p>Modules are defined through build scripts with <code>.scm</code> extension:</p>
<pre><code>name = hello
summary = hello
outType = exe
version = 1.0
depends = sric 1.0, cstd 1.0
srcDirs = ./
</code></pre>
<p>The source directory srcDirs must end with <code>/.</code> The compiler will automatically search all .sric files in the directory.</p>
<h3 id="module-import"><a class="header" href="#module-import">Module Import</a></h3>
<p>Import external modules in code:</p>
<pre><code>import sric::*;
import sric::DArray;
</code></pre>
<p>Where <code>*</code> imports all symbols under the module. Imported modules must be declared in the depends field of the build script.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h2>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<ul>
<li><code>sric</code>: Built-in standard library</li>
<li><code>cstd</code>: C standard library wrappers</li>
<li><code>jsonc</code>: JSON parsing/compression</li>
<li><code>serial</code>: Serialization using dynamic reflection</li>
</ul>
<p><a href="stdlib//apidoc.html">API Documentation</a></p>
<h3 id="using-c-libraries"><a class="header" href="#using-c-libraries">Using C Libraries</a></h3>
<p>The <code>cstd</code> module only exports common C functions - contributions welcome.</p>
<p>To use unexported C functions:</p>
<pre><code class="language-sric">externc fun printf(format: raw* const Int8, args: ...);

fun main() {
    printf("Hello World\n");
}
</code></pre>
<p>Declare macros as const variables. See C++ Interop for details.</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>Strings are raw* const Int8 but auto-convert to String:</p>
<pre><code class="language-sric">var str: String = "abc";
</code></pre>
<p>Explicit conversion when needed:</p>
<pre><code class="language-sric">var str = asStr("abc");
</code></pre>
<h3 id="darray"><a class="header" href="#darray">DArray</a></h3>
<p>Dynamic array (like C++ std::vector):</p>
<pre><code class="language-sric">var a : DArray$&lt;Int&gt;;
a.add(1);
a.add(2);
verify(a[0] == 1);
</code></pre>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>Key-value storage:</p>
<pre><code class="language-sric">var map = HashMap$&lt;Int, String&gt;{};
map.set(1, "1");
map.set(2, "2");
verify(map[2] == "2");
</code></pre>
<h2 id="file-io"><a class="header" href="#file-io">File I/O</a></h2>
<p>Using FileStream:</p>
<p>Write:</p>
<pre><code class="language-sric">var stream = FileStream::open("tmp.txt", "wb");
stream.writeStr("Hello\nWorld");
</code></pre>
<p>Read:</p>
<pre><code class="language-sric">var stream = FileStream::open("tmp.txt", "rb");
var line = stream.readAllStr();
</code></pre>
<p>Mode strings match C's fopen().</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>Sric provides C++-style smart pointers including SharedPtr, and WeakPtr.</p>
<h2 id="sharedptr"><a class="header" href="#sharedptr">SharedPtr</a></h2>
<p>Reference-counted with some overhead. Can be created from existing own*:</p>
<pre><code class="language-sric">var p = new Int;
var sp: SharedPtr$&lt;Int&gt; = toShared(p);
</code></pre>
<p>Convertible with own*:</p>
<pre><code class="language-sric">var p = sharedPtr.getOwn();
sharedPtr.set(p);
</code></pre>
<h2 id="weakptr"><a class="header" href="#weakptr">WeakPtr</a></h2>
<p>Breaks circular references that could cause memory leaks with own*/SharedPtr:</p>
<pre><code class="language-sric">var p = new Int;
var wp: WeakPtr$&lt;Int&gt; = toWeak(p);
</code></pre>
<p>Use via lock() which returns nullable own*:</p>
<pre><code class="language-sric">var sp : own*? Int = wp.lock();
</code></pre>
<p>Returns null if referenced object was freed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wase"><a class="header" href="#wase">Wase</a></h1>
<p>Wase is a cross-platform UI library developed by Sric. With a single codebase, it can be compiled and run on both desktop and web browsers, with future support for Android and iOS development. Wase offers a rich set of controls and elegant interfaces. Support creation UI from configuration file and support custom styles. It employs a self-rendering approach, similar to Qt and Flutter, but is more lightweight. The Sric language has specially designed comma-expression syntax for Wase, enabling a declarative API style comparable to SwiftUI and React Native.</p>
<p>learn more: <a href="https://github.com/sric-language/wase">https://github.com/sric-language/wase</a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="reflection"><a class="header" href="#reflection">Reflection</a></h3>
<p>Reflection is disabled by default and requires explicit <code>reflect</code> marker:</p>
<pre><code class="language-sric">reflect struct Point {
    var x: Int;
    var y: Int;
}
</code></pre>
<p>Annotations can be accessed through reflection API:</p>
<pre><code class="language-sric">//@SimpleSerial
reflect struct Point {
    var x: Int;
    var y: Int;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h2>
<p>Sric's coroutines are almost identical to JavaScript's. Here's an example:</p>
<pre><code class="language-sric">async fun test2() : Int {
    var i = 0;
    i = await testCallback();
    printf("await result:%d\n", i);
    return i + 1;
}
</code></pre>
<ul>
<li>Coroutine functions are marked with <code>async</code></li>
<li>The target of await must be either an async function or a function returning <code>Promise$&lt;T&gt;</code></li>
<li>The return value of async functions is automatically wrapped into <code>Promise$&lt;T&gt;</code> by the compiler</li>
</ul>
<h3 id="c-coroutine-adaptation"><a class="header" href="#c-coroutine-adaptation">C++ Coroutine Adaptation</a></h3>
<h4 id="integrating-with-event-loop"><a class="header" href="#integrating-with-event-loop">Integrating with Event Loop</a></h4>
<p>Sric coroutines are scheduled through the main event loop. The pseudocode shows integration with different event loop implementations:</p>
<pre><code class="language-sric">sric::call_later = [](std::function&lt;void()&gt; h){
    call_in_loop([]{ 
        h();
    });
};
</code></pre>
<h4 id="adapting-asynchronous-callback-interfaces"><a class="header" href="#adapting-asynchronous-callback-interfaces">Adapting Asynchronous Callback Interfaces</a></h4>
<p>Allocate <code>sric::Promise&lt;T&gt;::ResultData</code> on heap and call its on_done method in callback:</p>
<pre><code class="language-sric">sric::Promise&lt;int&gt; testCallback() {
    auto resultData = std::make_shared&lt;sric::Promise&lt;int&gt;::ResultData &gt;();
    std::thread([=]() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        resultData-&gt;on_done(1);
    }).detach();
    return sric::Promise&lt;int&gt;(resultData);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="interoperability-with-c-1"><a class="header" href="#interoperability-with-c-1">Interoperability with C++</a></h2>
<p>Sric can easily interact with C++. It compiles to human-readable C++ code that can be directly called like regular C++ code.</p>
<p>To call C++ code, simply declare the function prototypes. Use:</p>
<ul>
<li><code>externc</code> for C-style/no-namespace code</li>
<li><code>extern</code> for matching namespaces</li>
<li>Symbol mapping for other cases</li>
</ul>
<h3 id="c-styleno-namespace"><a class="header" href="#c-styleno-namespace">C-style/No Namespace</a></h3>
<pre><code class="language-sric">externc fun printf(format: raw* const Int8, args: ...);

fun main() {
    printf("Hello World\n");
}
</code></pre>
<h3 id="matching-namespaces"><a class="header" href="#matching-namespaces">Matching Namespaces</a></h3>
<p>When C++ namespace matches Sric module name:
C++:</p>
<pre><code class="language-cpp">namespace xx {
    class P {
        void foo();
    };
}
</code></pre>
<p>Sric:</p>
<pre><code class="language-sric">//xx module
extern struct P {
    fun foo();
}
</code></pre>
<p>Module name must match C++ namespace.</p>
<h3 id="symbol-mapping"><a class="header" href="#symbol-mapping">Symbol Mapping</a></h3>
<p>Use symbol annotation to map symbols:
C++:</p>
<pre><code class="language-cpp">namespace test {
    void hi() {
    }
}
</code></pre>
<p>Sric:</p>
<pre><code class="language-sric">//@extern symbol: test::hi
extern fun hello();
</code></pre>
<p>Calling hello() in Sric invokes C++'s hi().</p>
<h3 id="header-inclusion"><a class="header" href="#header-inclusion">Header Inclusion</a></h3>
<p>Use @#include annotation to include C++ headers:</p>
<pre><code class="language-sric">//@#include "test.h"
</code></pre>
<h3 id="parameterized-constructors"><a class="header" href="#parameterized-constructors">Parameterized Constructors</a></h3>
<p>Since Sric doesn't support parameterized constructors, use makePtr/makeValue instead.</p>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<pre><code class="language-sric">import sric::*;

//@#include &lt;vector&gt;
//@extern symbol: std::vector
extern struct vector$&lt;T&gt; {
    fun size(): Int;
}

fun testExtern() {
    var v = makePtr$&lt;vector$&lt;Int&gt;&gt;(3);
    verify(v.size() == 3);
}

fun testExtern2() {
    var v2 = makeValue$&lt;vector$&lt;Int&gt;&gt;(3);
    verify(v2.size() == 3);
}
</code></pre>
<h3 id="generating-sric-interfaces-from-c-headers"><a class="header" href="#generating-sric-interfaces-from-c-headers">Generating Sric Interfaces from C++ Headers</a></h3>
<p>Use Python scripts in the tool directory to generate Sric prototypes from C++ headers.</p>
<h3 id="compiling-without-fmake"><a class="header" href="#compiling-without-fmake">Compiling Without fmake</a></h3>
<p>You can manually compile generated C++ code in sric/output directory.</p>
<p>Define these macros:</p>
<ul>
<li>SC_CHECK: Enable safety checks</li>
<li>SC_NO_CHECK: Disable safety checks</li>
</ul>
<p>If neither is defined, they're automatically set based on _DEBUG/NDEBUG.</p>
<h3 id="mixed-sricc-compilation"><a class="header" href="#mixed-sricc-compilation">Mixed Sric/C++ Compilation</a></h3>
<p>Add fmake configurations in module.scm (prefix with fmake.):</p>
<pre><code class="language-sric">fmake.srcDirs = ./
fmake.incDirs = ./
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Sric supports serialization through built-in dynamic reflection, using the <a href="https://github.com/chunquedong/jsonc">HiML</a> text format.</p>
<h3 id="serialization-example"><a class="header" href="#serialization-example">Serialization Example</a></h3>
<p>Classes to be serialized require the <code>reflect</code> marker:</p>
<pre><code class="language-sric">reflect struct Point {
    var x: Int;
    var y: Float;
}

unsafe fun testSimple() {
    var encoder: Encoder;
    var obj = new Point { .x = 1; .y = 2; };
    var t = obj as *Void;
    var res = encoder.encode(t, "testSerial::Point");
    printf("%s\n", res.c_str());

    var decoder: Decoder;
    var p = decoder.decode(res);
    var obj2: raw* Point = unsafeCast$&lt;raw*Point&gt;(p);
    
    verify(obj2.x == obj.x);
    verify(obj2.y == obj.y);
}
</code></pre>
<p>For non-polymorphic objects like Point, the type name "testSerial::Point" must be explicitly provided.</p>
<h3 id="skipping-serialization"><a class="header" href="#skipping-serialization">Skipping Serialization</a></h3>
<p>Use Transient annotation to exclude fields:</p>
<pre><code class="language-sric">reflect struct Point {
    var x: Int;
    //@Transient
    var y: Float;
}
</code></pre>
<h3 id="post-deserialization-handling"><a class="header" href="#post-deserialization-handling">Post-Deserialization Handling</a></h3>
<p>The _onDeserialize method is automatically called after deserialization:</p>
<pre><code class="language-sric">reflect struct Point {
    var x: Int;
    fun _onDeserialize() {
    }
}
</code></pre>
<h3 id="simple-serialization-mode"><a class="header" href="#simple-serialization-mode">Simple Serialization Mode</a></h3>
<p>Normally custom classes serialize as HiML objects. The <code>SimpleSerial</code> annotation enables string serialization (e.g. "1 2 3 4" instead of structured format<code>Insets{top=1,right=2,bottom=3,left=4}</code>):</p>
<pre><code class="language-sric">//@SimpleSerial
reflect struct Insets {
    var top: Int = 0;
    var right: Int = 0;
    var bottom: Int = 0;
    var left: Int = 0;

    fun toString() : String {
        return String::format("%d %d %d %d", top, right, bottom, left);
    }

    fun fromString(str: String): Bool {
        var fs = str.split(" ");
        if (fs.size() == 4) {
            top = fs[0].toInt32();
            right = fs[1].toInt32();
            bottom = fs[2].toInt32();
            left = fs[3].toInt32();
            return true;
        }
        return false;
    }
}
</code></pre>
<p>Serialization/deserialization automatically calls <code>toString</code> and <code>fromString</code> - these methods must exactly match the shown signatures.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="coding-conventions"><a class="header" href="#coding-conventions">Coding Conventions</a></h2>
<h3 id="source-files"><a class="header" href="#source-files">Source Files</a></h3>
<p>Source files must use UTF-8 encoding.</p>
<h3 id="indentation"><a class="header" href="#indentation">Indentation</a></h3>
<p>Use 4 spaces for indentation:</p>
<pre><code class="language-sric">    if (cond) {
        doTrue
    }
    else {
        doFalse
    }
</code></pre>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<ul>
<li>Type names use PascalCase</li>
<li>Module names, functions and variables use camelCase</li>
<li>Never use ALL_CAPS naming style</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h3 id="unicode-character-encoding-issues"><a class="header" href="#unicode-character-encoding-issues">Unicode Character Encoding Issues</a></h3>
<p>In Git Bash, run:</p>
<pre><code>cmd "/c chcp 65001&gt;nul"
</code></pre>
<p>In CMD, run:</p>
<pre><code>chcp 65001&gt;nul
</code></pre>
<h3 id="compiler-doesnt-support-c20"><a class="header" href="#compiler-doesnt-support-c20">Compiler Doesn't Support C++20</a></h3>
<p>Since coroutines require C++20, you can specify C++ version (note coroutine-related code will fail to compile):</p>
<pre><code>sric module.scm -fmake -c++17
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tool"><a class="header" href="#command-line-tool">Command Line Tool</a></h1>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The sric command supports these arguments:</p>
<ul>
<li><code>-debug</code> Compile in Debug mode (default is release mode)</li>
<li><code>-fmake</code> Use fmake to compile generated C++ code</li>
<li><code>-r</code> Recursively build all dependencies</li>
<li><code>-c++17</code> Use C++17 standard</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
